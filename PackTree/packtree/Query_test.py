import pack_tree as pt
from prettytable import PrettyTable

# Скрудж Мак-Дак. Скрудж Мак-Дак решил сделать прибор для управления
# самолетом. Как известно, положение штурвала зависит от состояния входных
# датчиков, но эта функция довольно сложна. Его механик сделал устройство, вычисляющее
# эту функцию за несколько этапов с использованием промежуточной
# памяти и вспомогательных функций. Для вычисления каждой из функций требуется, чтобы в ячейках памяти уже находились вычисленные парамет-
# ры (которые являются значениями вычисленных функций), необходимые для
# ее вычисления. Вычисление функции без параметров может производиться в
# любое время. После вычисления функции ячейки могут быть использованы
# повторно (хотя бы для записи результата вычисленной функции). Структура
# вызова функций такова, что каждая функция вычисляется не более одного
# раза, и любой параметр используется не более одного раза. Любой параметр
# есть имя функции. Так как Скрудж не хочет тратить лишних денег на мик-
# росхемы, он поставил задачу минимизировать память прибора. По заданной
# структуре вызовов функций необходимо определить минимально возможный
# размер памяти прибора и указать последовательность вычисления функций.

Func = pt.Tree(["f", "g1", "g2", "h1", "h2", "h3", "u1", "u2", "u3", "v1", "v2"],
             [("f", "g1"), ("f", "g2"),
              ("g1", "h1"), ("g1", "h2"), ("g2", "h3"),
              ("h2", "u1"), ("h2", "u2"), ("h2", "u3"),
              ("u3", "v1"), ("u3", "v2")])

num = Func.Pack_min_width()

table = PrettyTable()

detal_func = list(num.keys())
det_f = []

row = []
count_ram = 0

while detal_func:
    det_f.append(detal_func.pop())
    while len(det_f) > 1 and det_f[-1] == Func.parent(det_f[-2]):
        det_f.pop(-2)
    row.append(list(det_f))

table.add_column("такт", [i for i in range(len(num))])
table.add_column("состояние в памяти", row)
table.add_column("кол-во ячеек памяти", [len(row[i]) for i in range(len(row))])

print(table)